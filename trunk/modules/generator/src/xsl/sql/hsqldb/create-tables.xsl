<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright 2012 Spolecne s.r.o. (www.spoledge.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *-->
<xsl:stylesheet
	version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:db="http://www.spoledge.com/audao"
	>

	<xsl:import href="..@DIR_SEP@create-tables.xsl"/>

	<xsl:param name="db_user"/>

	<xsl:template name="db-prolog">
		<xsl:text>-- ======================== HSSQL P R O L O G ====================
-- manually: DROP ROLE ACCESS_RO;
-- manually: CREATE ROLE ACCESS_RO;
-- manually: DROP ROLE ACCESS_RW;
-- manually: CREATE ROLE ACCESS_RW;
-- manually: DROP USER </xsl:text>
		<xsl:value-of select="$db_user"/>
		<xsl:text>;
-- manually: CREATE user </xsl:text>
		<xsl:value-of select="$db_user"/>
		<xsl:text> PASWORD your_password [ADMIN];
-- manually: GRANT ACCESS_RW TO </xsl:text>
		<xsl:value-of select="$db_user"/>
		<xsl:text>;

</xsl:text>
	</xsl:template>


	<xsl:template name="db-epilog">
		<xsl:text>-- ======================== HSSQL E P I L O G ====================
</xsl:text>
		<xsl:for-each select="//db:tables/db:table[not(@abstract)]">
			<xsl:text>-- GRANT SELECT, INSERT, UPDATE, DELETE ON </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> TO ACCESS_RW;
-- GRANT SELECT ON </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> TO ACCESS_RO;
</xsl:text>
			<xsl:for-each select="db:columns/db:column[db:auto and (db:type='short' or db:type='int' or db:type='long')]">
				<xsl:text>-- GRANT USAGE ON SEQUENCE </xsl:text>
				<xsl:call-template name="sequence-name"/>
				<xsl:text> TO ACCESS_RW;
</xsl:text>
			</xsl:for-each>
		</xsl:for-each>
		<xsl:text>
COMMIT;
SHUTDOWN;
</xsl:text>
	</xsl:template>


	<xsl:template name="db-table-before">
		<xsl:call-template name="sequences"/>
	</xsl:template>

	<xsl:template name="db-table-after">
		<xsl:call-template name="indexes"/>
	</xsl:template>


	<xsl:template name="db-column-epilog">
		<xsl:if test="db:auto and (db:type='short' or db:type='int' or db:type='long')">
			<xsl:text> GENERATED BY DEFAULT AS SEQUENCE </xsl:text>
			<xsl:call-template name="sequence-name"/>
		</xsl:if>
		<xsl:if test="db:not-null and not(db:pk)">
			<xsl:text> NOT NULL</xsl:text>
		</xsl:if>
		<xsl:if test="db:pk">
			<xsl:text> PRIMARY KEY</xsl:text>
		</xsl:if>
	</xsl:template>

	<xsl:template name="db-type">
		<xsl:choose>
			<xsl:when test="db:type = 'boolean'">
				<xsl:text>tinyint</xsl:text>
			</xsl:when>
			<xsl:when test="db:type = 'short'">
				<xsl:text>smallint</xsl:text>
			</xsl:when>
			<xsl:when test="db:type = 'int'">
				<xsl:text>integer</xsl:text>
			</xsl:when>
			<xsl:when test="db:type = 'long'">
				<xsl:text>bigint</xsl:text>
			</xsl:when>
			<xsl:when test="db:type = 'double'">
				<xsl:text>double</xsl:text>
			</xsl:when>
			<xsl:when test="db:type = 'String'">
				<xsl:text>varchar(</xsl:text>
				<xsl:value-of select="db:type/@max-length"/>
				<xsl:text>)</xsl:text>
			</xsl:when>
			<xsl:when test="db:type = 'Date'">
				<xsl:text>date</xsl:text>
			</xsl:when>
			<xsl:when test="db:type = 'Timestamp'">
				<xsl:text>timestamp</xsl:text>
			</xsl:when>
			<xsl:when test="db:type = 'byte[]' or db:type='Serializable'">
				<xsl:text>blob</xsl:text>
				<xsl:if test="db:type/@max-length">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="db:type/@max-length"/>
					<xsl:text>)</xsl:text>
				</xsl:if>
			</xsl:when>
			<xsl:otherwise>
				<xsl:message>The type '<xsl:value-of select="db:type"/>' is not supported 'db-data-column'</xsl:message>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>


	<xsl:template name="db-data-column">
		<xsl:param name="type"/>
		<xsl:param name="val"/>

		<xsl:choose>
			<xsl:when test="$type = 'boolean'">
				<xsl:choose>
					<xsl:when test="$val = 'true'">
						<xsl:text>1</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>0</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="$type = 'short'">
				<xsl:value-of select="$val"/>
			</xsl:when>
			<xsl:when test="$type = 'int'">
				<xsl:value-of select="$val"/>
			</xsl:when>
			<xsl:when test="$type = 'long'">
				<xsl:value-of select="$val"/>
			</xsl:when>
			<xsl:when test="$type = 'String'">
				<xsl:text>'</xsl:text>
				<xsl:value-of select="$val"/>
				<xsl:text>'</xsl:text>
			</xsl:when>
			<xsl:when test="$type = 'Date'">
				<xsl:text>'</xsl:text>
				<xsl:value-of select="$val"/>
				<xsl:text>'</xsl:text>
			</xsl:when>
			<xsl:when test="$type = 'Timestamp'">
				<xsl:text>'</xsl:text>
				<xsl:value-of select="$val"/>
				<xsl:text>'</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:message>The type '<xsl:value-of select="$type"/>' is not supported 'db-data-column'</xsl:message>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>


	<xsl:template name="indexes">
		<xsl:for-each select="db:indexes/db:index">
			<xsl:text>CREATE </xsl:text>
			<xsl:if test="db:unique">
				<xsl:text>UNIQUE </xsl:text>
			</xsl:if>
			<xsl:text>INDEX </xsl:text>
			<xsl:call-template name="schema-prefix">
				<xsl:with-param name="ctx" select="../.."/>
			</xsl:call-template>
			<xsl:value-of select="@name"/>
			<xsl:text> ON </xsl:text>
			<xsl:call-template name="db-name">
				<xsl:with-param name="ctx" select="../.."/>
			</xsl:call-template>
			<xsl:text> (</xsl:text>
			<xsl:for-each select="db:columns/db:column">
				<xsl:call-template name="comma-if-next"/>
				<xsl:text>
	</xsl:text>
				<xsl:value-of select="@name"/>
			</xsl:for-each>
			<xsl:text>
);

</xsl:text>
		</xsl:for-each>
	</xsl:template>


	<xsl:template name="db-foreign-key">
		<xsl:param name="ctx"/>
		<xsl:param name="tname"/>
		<xsl:param name="fk"/>
		<!-- MySQL creates indexes automatically:
		<xsl:call-template name="check-ref-index">
			<xsl:with-param name="tname" select="$tname"/>
		</xsl:call-template>
		-->
		<xsl:call-template name="add-constraint">
			<xsl:with-param name="tname" select="$ctx/../../@name"/>
		</xsl:call-template>
		<xsl:value-of select="$fk"/>
		<xsl:text> FOREIGN KEY (
	</xsl:text>
		<xsl:value-of select="$ctx/@name"/>
		<xsl:text>
)
REFERENCES </xsl:text>
		<xsl:value-of select="$tname"/>
		<xsl:text> (
	</xsl:text>
		<xsl:value-of select="$ctx/db:ref/@column"/>
		<xsl:text>
);

</xsl:text>
	</xsl:template>


	<xsl:template name="sequences">
		<xsl:for-each select="db:columns/db:column[db:auto][db:type='short' or db:type='int' or db:type='long']">
			<xsl:text>CREATE SEQUENCE </xsl:text>
			<xsl:call-template name="sequence-name"/>
			<!-- HSQL sequences start with 0, but we have in docs 1: -->
			<xsl:text> START WITH </xsl:text>
			<xsl:choose>
				<xsl:when test="db:auto/@start">
					<xsl:value-of select="db:auto/@start"/>
				</xsl:when>
				<xsl:when test="../../db:data/db:row">
					<xsl:text> START WITH </xsl:text>
					<xsl:value-of select="count(../../db:data/db:row) + 1"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>1</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>;

</xsl:text>
		</xsl:for-each>
	</xsl:template>


	<xsl:template name="sequence-name">
		<xsl:choose>
			<xsl:when test="db:auto/@sequence">
				<xsl:value-of select="db:auto/@sequence"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="schema-prefix">
					<xsl:with-param name="ctx" select="../.."/>
				</xsl:call-template>
				<xsl:text>seq_</xsl:text>
				<xsl:value-of select="../../@name"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>


	<xsl:template name="not-null-constraint">
	</xsl:template>

</xsl:stylesheet>
