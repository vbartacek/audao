<div class="chapter">
<a name="gae-features"></a>
<h1 class="chapter">Google App Engine Specific Features</h1>

<p class="chapter-abstract">
	This chapter describes DAO generator features specific for Google App Engine target.
</p>


<div class="section">
<a name="types"></a>
<h2>GAE Types</h2>


<div class="subsection">
<a name="typecore"></a>
<h3>GAE Core Types</h3>

<p>
	As of the version 1.2 we support all GAE core types including Key, GeoPt or User.
</p>

<p>
	AuDAO recognizes all GAE core classes by the <tt>column/type/@class</tt> attribute
	for types <a href="[dao-features]#typeSerializable">Serializable</a>
	and <a href="[dao-features]#typeList">List</a>. If you specify a non-core GAE class,
	then it is stored as GAE types Blob or ShortBlob - according to the attribute
	<tt>column/type/@max-length</tt> (ShortBlob is used only when <tt>max-length</tt> &lt;= 500).
</p>

<p>
	For the GAE specific objects the <tt>column/type/@class</tt> attribute must start
	with prefix "gae:" following by the simple class name - for example <tt>class="gae:GeoPt"</tt>.
	Example of the XML:
	<pre class="prettyprint xml">
  &lt;column name="location"&gt;
    &lt;type class="gae:GeoPt"&gt;Serializable&lt;/type&gt;
  &lt;/column&gt; </pre>
  will allow you to pass GeoPt objects directly into your DTOs:
  <pre class="prettyprint java">
  dto.setLocation( new GeoPt( latitude, longitude )); </pre>
</p>

<p class="note">
	Do not specify the attribute <tt>column/type/@max-length</tt> for GAE core types.
	If you do so, then the objects will be stored as Blob or ShortBlob - according to the <tt>max-length</tt>'
	value.
</p>

<p>
	<b>See also</b>: <a href="[xsd:ColumnTypeType]">XSD - column type</a>
</p>

</div>


<div class="subsection">
<a name="typelist"></a>
<h3>Lists</h3>

<p>
	As of the version 1.2 the lists support almost the same types as simple fields
	including all GAE core types like  Key, GeoPt or User.
	The only restriction is that lists cannot contain enumeration types now.
</p>

<p>
	We recognize the following list types:
</p>

<table class="matrix" width="100%">
	<tr class="header">
		<td>Name</td>
		<td>Example of Java Type</td>
		<td>Example of XML Definition</td>
		<td>Elements Stored as</td>
	</tr>

	<tr>
		<td>list of core java.lang types</td>
		<td><code class="prettyprint">List&lt;Boolean&gt;</code></td>
		<td><code class="prettyprint">List&lt;Boolean&gt;</code></td>
		<td><code class="prettyprint">Boolean</code></td>
	</tr>

	<tr>
		<td>list of java.util.Date</td>
		<td><code class="prettyprint">List&lt;java.util.Date&gt;</code></td>
		<td><code class="prettyprint">&lt;type class="java.util.Date"&gt;List&lt;/type&gt;</code></td>
		<td><code class="prettyprint">java.util.Date</code></td>
	</tr>

	<tr>
		<td>list of other GAE core types</td>
		<td><code class="prettyprint">List&lt;GeoPt&gt;</code></td>
		<td><code class="prettyprint">&lt;type class="gae:GeoPt"&gt;List&lt;/type&gt;</code></td>
		<td><code class="prettyprint">GeoPt</code></td>
	</tr>

	<tr>
		<td>list of other DTO types - short</td>
		<td><code class="prettyprint">List&lt;MyDto&gt;</code></td>
		<td><code class="prettyprint">&lt;type class="table:my_dto" max-length="500"&gt;List&lt;/type&gt;</code></td>
		<td><code class="prettyprint">ShortBlob</code></td>
	</tr>

	<tr>
		<td>list of other DTO types</td>
		<td><code class="prettyprint">List&lt;MyDto&gt;</code></td>
		<td><code class="prettyprint">&lt;type class="table:my_dto"&gt;List&lt;/type&gt;</code></td>
		<td><code class="prettyprint">Blob</code></td>
	</tr>

	<tr>
		<td>list of other types - short</td>
		<td><code class="prettyprint">List&lt;com.foo.MyClass&gt;</code></td>
		<td><code class="prettyprint">&lt;type class="com.foo.MyClass" max-length="500"&gt;List&lt;/type&gt;</code></td>
		<td><code class="prettyprint">ShortBlob</code></td>
	</tr>

	<tr>
		<td>list of other types</td>
		<td><code class="prettyprint">List&lt;com.foo.MyClass&gt;</code></td>
		<td><code class="prettyprint">&lt;type class="com.foo.MyClass"&gt;List&lt;/type&gt;</code></td>
		<td><code class="prettyprint">Blob</code></td>
	</tr>

	<tr>
		<td>native list</td>
		<td><code class="prettyprint">List</code></td>
		<td><code class="prettyprint">&lt;type class="java.util.List"&gt;Serializable&lt;/type&gt;</code></td>
		<td>exactly as stored in list</td>
	</tr>

	<tr>
		<td>anonymous list - short</td>
		<td><code class="prettyprint">List</code></td>
		<td><code class="prettyprint">&lt;type max-length="500"&gt;List&lt;/type&gt;</code></td>
		<td><code class="prettyprint">ShortBlob</code></td>
	</tr>

	<tr>
		<td>anonymous list</td>
		<td><code class="prettyprint">List</code></td>
		<td><code class="prettyprint">&lt;type&gt;List&lt;/type&gt;</code></td>
		<td><code class="prettyprint">Blob</code></td>
	</tr>

</table>

<p>
	Native lists allow you to store exactly what you want - no conversions are performed.
	It is your responsibility to store to list only types supported by GAE.
</p>

<p>
	Anonymous lists allow you to create lists of several types objects which are
	converted to Blobs or ShortBlobs.
</p>

<p>
	<b>See also</b>: <a href="[xsd:ColumnTypeType]">XSD - column type</a>
</p>

</div>


</div> <!-- section -->


<div class="section">
<a name="storage"></a>
<h2>Storage Options</h2>

<p>
	GAE's datastore is schema-less and defines one column indexes by default.
	We will show you how to optimize DAOs generated by AuDAO.
</p>

<div class="subsection">
<a name="storage-empty"></a>
<h3>Do Not Store Null Values</h3>

<p>
	By default AuDAO generates code which stores <tt>null</tt> values.
	This is similar to normal RDBMS. But null values occupies a place in the storage
	and also consumes CPU when storing/retrieving. AuDAO allows you to not store null
	values optionally.
</p>

<p>
	You can specify exactly in which columns/properties your DAOs will store nulls and where don't.
	It is specified by the <tt>&lt;gae empty="true"&gt;</tt> flag added to the column definition.
</p>

<p>
	<b>Example:</b>
	<pre class="prettyprint xml">
  &lt;column name="normal_type"&gt;
    &lt;type max-length="500"&gt;String&lt;/type&gt;
    &lt;not-null/&gt;
    &lt;edit/&gt;
  &lt;/column&gt;

  &lt;column name="null_normal_type"&gt;
    &lt;ref column="normal_type"/&gt;
    &lt;edit/&gt;
  &lt;/column&gt;

  &lt;column name="null_empty_type"&gt;
    &lt;ref column="normal_type"/&gt;
    &lt;edit/&gt;
    <b>&lt;gae empty="true"/&gt;</b>
  &lt;/column&gt; </pre>

	The <tt>null_empty_type</tt> column does not store nulls,
	the <tt>null_normal_type</tt> column stores nulls
	and the <tt>normal_type</tt> column does not store nulls - it is a <tt>&lt;not-null/&gt;</tt> column.
</p>

<p>
	You can only tag as <tt>empty</tt> columns which are not <tt>&lt;not-null/&gt;</tt>.
	the following example shows nonsense definitions:
	<pre class="prettyprint xml">
  &lt;!-- nonsense
  &lt;column name="empty_type"&gt;
    &lt;ref column="normal_type"/&gt;
    <b>&lt;not-null/&gt;</b>
    &lt;edit/&gt;
    <b>&lt;gae empty="true"/&gt;</b>
  &lt;/column&gt;
  --&gt; </pre>
</p>

<p class="note">
	You cannot search for <tt>null</tt> values in columns which do not store nulls.
	If you want to search for <tt>null</tt> values, then you have to let you DAOs
	to store nulls into datastore.
</p>

<p>
	<b>See also</b>: <a href="[xsd:GaeColumnExtType]">XSD - gae element</a>
</p>

</div>


<div class="subsection">
<a name="storage-unindexed"></a>
<h3>Explicit Unindexed Columns</h3>

<p>
	By default AuDAO generates code which stores column values as indexed ones.
	It means that you can search for values stored in such columns.
	But it also means that an index is created for such column and such index
	occupies space in the datastore. Also additional CPU is needed when storing/updating
	whole entity.
</p>

<p>
	AuDAO allows you to disable such indexing for the given column explicitly.
	It is specified by the <tt>&lt;gae unindexed="true"&gt;</tt> flag added to the column definition.
</p>

<p class="note">
	If a column is tagged as <tt>unindexed</tt>, it behave as <a href="#storage-empty">empty</a> 
	for null values - it means that no null values are stored in such column.
	The reason is obvious: you cannot search by the unindexed columns and <tt>null</tt> values
	would only occupy place in the datastore without any advantage.
</p>

<p>
	<b>Example:</b>
	<pre class="prettyprint xml">
  &lt;column name="normal_type"&gt;
    &lt;type max-length="500"&gt;String&lt;/type&gt;
    &lt;not-null/&gt;
    &lt;edit/&gt;
  &lt;/column&gt;

  &lt;column name="unindexed_type"&gt;
    &lt;ref column="normal_type"/&gt;
    &lt;not-null/&gt;
    &lt;edit/&gt;
    <b>&lt;gae unindexed="true"/&gt;</b>
  &lt;/column&gt;

  &lt;column name="null_normal_type"&gt;
    &lt;ref column="normal_type"/&gt;
    &lt;edit/&gt;
  &lt;/column&gt;

  &lt;column name="null_unindexed_type"&gt;
    &lt;ref column="normal_type"/&gt;
    &lt;edit/&gt;
    <b>&lt;gae unindexed="true"/&gt;</b>
  &lt;/column&gt;

  &lt;column name="null_empty_unindexed_type"&gt;
    &lt;ref column="normal_type"/&gt;
    &lt;edit/&gt;
    <b>&lt;gae unindexed="true" empty="true"/&gt;</b>
  &lt;/column&gt; </pre>

	The <tt>null_empty_unindexed_type</tt> column does not store nulls,
	but the <tt>empty</tt> flag is useless,
	the <tt>null_unindexed_type</tt> column does not store nulls,
	the <tt>null_normal_type</tt> column stores nulls and you can search by all values
	and the <tt>unindexed_type</tt> column does not store nulls - it is a <tt>&lt;not-null/&gt;</tt> column.
</p>

<p>
	<b>See also</b>: <a href="[xsd:GaeColumnExtType]">XSD - gae element</a>
</p>

</div>


</div> <!-- section -->


<div class="section">
<a name="gqlFinders"></a>
<h2>Finders and Lists</h2>

<p>
	AuDAO offers you more functionalities concerning Lists.
	We will describe here the rules how <a href="[dao-features]#finders">finder</a>
	method signatures are constructed and how the finder filters are implemented.
</p>


<div class="subsection">
<a name="gqlFinderSignature"></a>
<h2>Finder Signature - List or Element</h2>

<p>
	The basic rule how finder signatures are generated is the following:
	<span style="font-weight:bold">the finder's parameter is a List if and only if you explicitly specify it</span>.
</p>

<p>
	The following example shows usage of <a href="[dao-features]#finderIndex">index finders</a>:
	<pre class="prettyprint xml">
  &lt;columns&gt;
    &lt;column name="location"&gt;
      &lt;type class="gae:GeoPt"&gt;Serializable&lt;/type&gt;
    &lt;/column&gt;
    &lt;column name="friends"&gt;
      &lt;type class="gae:User"&gt;List&lt;/type&gt;
    &lt;/column&gt;
  &lt;/columns&gt;
  &lt;indexes&gt;
    &lt;index name="inx_location"&gt;
      &lt;columns&gt;
        &lt;column name="location"/&gt;
      &lt;/columns&gt;
    &lt;/index&gt;
    &lt;index name="inx_friends"&gt;
      &lt;columns&gt;
        &lt;column name="friends"/&gt;
      &lt;/columns&gt;
    &lt;/index&gt;
  &lt;/indexes&gt;
  &lt;methods&gt;
    &lt;find&gt;
      &lt;index name="inx_location"/&gt;
    &lt;/find&gt;
    &lt;find name="byOneFriend"&gt;
      &lt;index name="inx_friends"/&gt;
    &lt;/find&gt;
    &lt;find name="byAllFriends"&gt;
      &lt;index name="inx_friends" list="true"/&gt;
    &lt;/find&gt;
  &lt;/methods&gt; </pre>

	will generate these DAO methods:
	<pre class="prettyprint java">
  public MyEntity[] findByLocation( GeoPt location );
  public MyEntity[] findByOneFriend( User friends );
  public MyEntity[] findByAllFriends( List&lt;User&gt; friends ); </pre>

	You can see that only the last method <tt>findByAllFriends</tt> was generated with a List parameter,
	because the only one explicitly defined the <tt>list</tt> attribute.
</p>

<p>
	The following example shows the same + two more methods generated using
	<a href="[dao-features]#finderCondition">condition finders</a> (same columns as above):
	<pre class="prettyprint xml">
  &lt;methods&gt;
    &lt;find name="byLocation"&gt;
      &lt;condition&gt;
        &lt;query&gt;location = :1&lt;/query&gt;
        &lt;params&gt;
          &lt;column name="location"/&gt;
        &lt;/params&gt;
      &lt;/condition&gt;
    &lt;/find&gt;
    &lt;find name="byLocations"&gt;
      &lt;condition&gt;
        &lt;query&gt;location IN :1&lt;/query&gt;
        &lt;params&gt;
          &lt;!-- @java specifies the param name in java --&gt;
          &lt;column name="location" list="true" java="locations"/&gt;
        &lt;/params&gt;
      &lt;/condition&gt;
    &lt;/find&gt;
    &lt;find name="byOneFriend"&gt;
      &lt;condition&gt;
        &lt;query&gt;friends = :1&lt;/query&gt;
        &lt;params&gt;
          &lt;column name="friends" java="friend"/&gt;
        &lt;/params&gt;
      &lt;/condition&gt;
    &lt;/find&gt;
    &lt;find name="byAllFriends"&gt;
      &lt;condition&gt;
        &lt;query&gt;friends = :1&lt;/query&gt;
        &lt;params&gt;
          &lt;column name="friends" list="true"/&gt;
        &lt;/params&gt;
      &lt;/condition&gt;
    &lt;/find&gt;
    &lt;find name="bySomeFriends"&gt;
      &lt;condition&gt;
        &lt;query&gt;friends IN :1&lt;/query&gt;
        &lt;params&gt;
          &lt;column name="friends" list="true"/&gt;
        &lt;/params&gt;
      &lt;/condition&gt;
    &lt;/find&gt;
  &lt;methods&gt;</pre>

	will generate these DAO methods:
	<pre class="prettyprint java">
  public MyEntity[] findByLocation( GeoPt location );
  public MyEntity[] findByLocations( List&lt;GeoPt&gt; locations );
  public MyEntity[] findByOneFriend( User friend );
  public MyEntity[] findByAllFriends( List&lt;User&gt; friends );
  public MyEntity[] findBySomeFriends( List&lt;User&gt; friends ); </pre>

	Again, a List parameter is generated only when explicitly declared by the <tt>list</tt> attribute.
</p>

<p class="note">
	In the example above you can see that condition finders are more powerfull than index finders.
</p>


</div>


<div class="subsection">
<a name="gqlFinderExpandAnd"></a>
<h2>Expanded Conditions for List Properties</h2>

<p>
	In the examples in the previous section you have seen methods
	<tt>findByAllFriends( List&lt;User&gt; users)</tt>.
	It was an example of so called "expanded conditions".
</p>

<p>
	Normally, when a non-list parameter is passed to the finder, then the parameter is used
	in a plain condition like equality condition e.g. <tt>location = myparam</tt>.
</p>

<p>
	But when a list parameter is passed to the finder containing simple equality condition,
	then the simple equality condition is repeated and concatenated by 'AND' operator
	as many times as the list's values.
</p>

<p>
	<b>Example:</b>
	calling of
	<pre class="prettyprint java">dao.findByAllFriends( Arrays.asList( user1, user2, user3 ))</pre>
	will expand condition into
	<pre class="prettyprint xml">friends=user1 AND friends=user2 AND friends=user3</pre>
	It means that only entities which have all three users stored in their 'friends' property will be found.
</p>

<p class="note">
	Expanded conditions are allowed only for List properties.
</p>


</div>


<div class="subsection">
<a name="gqlFinderIn"></a>
<h2>"IN" Conditions</h2>

<p>
	"IN" conditions are allowed for both List and non-list properties.
	In our example the corresponding methods were <tt>findByLocations( List&lt;GeoPt&gt; locations)</tt>
	and <tt>findBySomeFriends( List&lt;User&gt; friends)</tt>.
</p>

<p>
	As the result of the "IN" operator it is a union of all entities matching at least with one list's
	element. In our examples it is when the entities' location is int the 'locations' list
	and when the entities' list of friends has at least one common item with the list of friends
	passed as the parameter.
</p>

</div>


</div> <!-- section -->



<div class="section">
<a name="gqlparser"></a>
<h2>Dynamic GQL Parser</h2>

<p>
	A part of AuDAO runtime libraries is a "Dynamic GQL Parser", which dynamically
	parses GQL string queries and converts them into GAE datastore API calls
	(GAE datastore API itself does not provide such functionality).
</p>

<p>
	This parser is used by all generated <a href="[dao-features]#finderDynamic">dynamic finders</a>.
	But the parser can be used as an independent module. The parser's code is an open-source - 
	distributed with the Apache License, Version 2.0 and you can download both source codes
	(audao-sources-*.zip) and Java binaries (audao-runtime-gql-*.jar)
	on the <a href="http://audao.spoledge.com/download.jsp">download</a> page.
</p>

<p>
	The GQL dynamic parser module (audao-runtime-gql-*.jar) has the following external dependencies:
	<ul>
		<li><a href="http://commons.apache.org">Apache Commons Logging Library</a> - common-logging*.jar</li>
		<li><a href="http://www.antlr.org">ANTLR3 Parser Generator Runtime Library</a> - antlr-runtime-3.2.jar</li>
	</ul>
</p>

<p>
	A bigger example of usage - GQL Console - you can find at
	<a href="http://vaclavb.blogspot.com/2010/02/google-app-engine-data-viewer-gql-java.html">http://vaclavb.blogspot.com/2010/02/google-app-engine-data-viewer-gql-java.html</a>
</p>

<p>
	<b>Example</b> - parses GQL string into low-level datastore Query:
	<pre class="prettyprint java">
  GqlDynamic gqld = new GqlDynamic();
  Query q = gqld.parseQuery( "SELECT * FROM MyEntity WHERE prop='test'" );</pre>
</p>

<p>
	<b>Example</b> - parses GQL string into low-level datastore PreparedQuery:
	<pre class="prettyprint java">
  GqlDynamic gqld = new GqlDynamic();
  gqld.setDatastoreService( DatastoreServiceFactory.getDatastoreService());

  PreparedQuery pq = gqld.prepareQuery(
      "SELECT * FROM MyEntity WHERE propName='test'" );</pre>
</p>

<p>
	<b>Example</b> - parses GQL string into PreparedQuery and FetchOptions:
	<pre class="prettyprint java">
  GqlDynamic gqld = new GqlDynamic();
  gqld.setDatastoreService( DatastoreServiceFactory.getDatastoreService());

  PreparedQuery pq = gqld.prepareQuery(
      "SELECT * FROM MyEntity WHERE propName='test' LIMIT 20" );

  for ( Entity ent : pq.asIterable( gqld.getFetchOptions())) {
      // process entities here
      ...
  }</pre>
</p>

<p>
	<b>Example</b> - parses GQL string with parameters into PreparedQuery and FetchOptions:
	<pre class="prettyprint java">
  GqlDynamic gqld = new GqlDynamic();
  gqld.setDatastoreService( DatastoreServiceFactory.getDatastoreService());

  PreparedQuery pq = gqld.prepareQuery(
      "SELECT * FROM MyEntity WHERE propName=:1 LIMIT 20", "test" );
  for ( Entity ent : pq.asIterable( gqld.getFetchOptions())) {
      // process entities here
      ...
  }</pre>
</p>

<p>
	<b>Example</b> - escaping kind and property names which conflict with GQL keywords:
	<pre class="prettyprint java">
  gqld.prepareQuery( "SELECT * FROM 'Order' WHERE 'limit'=:1", mylimit );</pre>
</p>

<p>
	<b>Example</b> - collections cause exploding condition into multiple ANDed conditions:
	<pre class="prettyprint java">
  gqld.prepareQuery(
      "SELECT * FROM MyEntity WHERE listProp=:1 AND singleProp=:2",
      Arrays.asList( 1, 2, 3), 4);</pre>
	the condition will be: <code>listProp=1 AND listProp=2 AND listProp=3 AND singleProp=4</code>
</p>

<p>
	<b>Example</b> - the IN operator accepts collections:
	<pre class="prettyprint java">
  gqld.prepareQuery(
      "SELECT * FROM MyEntity WHERE prop IN :1", Arrays.asList( 1, 2, 3));</pre>
</p>

<p>
	<b>Example</b> - the IN operator accepts hard-coded lists which values can be expressions (I heard that Python's parser did not allow this):
	<pre class="prettyprint java">
  gqld.prepareQuery(
      "SELECT * FROM MyEntity WHERE prop IN (:1, :2, KEY('Entity2', :3))",
      1, 2, "myKeyName");</pre>
</p>

<p>
	<b>See also</b>: <a href="[api:parser/gql::GqlDynamic]">GQLDynamic</a>
</p>

</div> <!-- section -->


</div> <!-- chapter -->

